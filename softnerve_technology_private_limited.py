# -*- coding: utf-8 -*-
"""softnerve-technology-private-limited.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/roshanoro/a4ee3367e070820f39b881c5d5cdb079/softnerve-technology-private-limited.ipynb
"""

#I am Installing necessary dependencies like playwright and installing chromadb and generative ai
!pip install -q playwright
!playwright install chromium

!pip install -q google-generativeai
!pip install -q chromadb ipywidgets

#configuring gemini api
import google.generativeai as genai

genai.configure(api_key="AIzaSyCYlHs9qzR9uSjTRR6msQ70vFsiovGCe4g")#this is my gemini api key
model = genai.GenerativeModel("gemini-1.5-flash-latest")

def call_gemini(prompt):
    response = model.generate_content(prompt)
    return response.text

#Scrape Chapter and Screenshot from the url
import asyncio
from playwright.async_api import async_playwright
import nest_asyncio

async def scrape_chapter(url, screenshot_path="chapter1.png"):
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        page = await browser.new_page()
        await page.goto(url)
        text = await page.inner_text("body")
        await page.screenshot(path=screenshot_path, full_page=True)
        await browser.close()
        return text

url = "https://en.wikisource.org/wiki/The_Gates_of_Morning/Book_1/Chapter_1"
nest_asyncio.apply() # Apply nest_asyncio to allow asyncio.run() in Colab
chapter_text = asyncio.run(scrape_chapter(url))
print(chapter_text[:1000])  # preview

# AI Writer & Reviewer (Using Gemini)
def ai_writer(text):
    prompt = f"Rewrite this creatively and engagingly:\n\n{text[:10000]}"
    return call_gemini(prompt)

def ai_reviewer(text):
    prompt = f"Review this text and improve clarity, grammar, and engagement:\n\n{text[:10000]}"
    return call_gemini(prompt)

spun_text = ai_writer(chapter_text)
reviewed_text = ai_reviewer(spun_text)

#Human-in-the-Loop Editing
from IPython.display import display
import ipywidgets as widgets

editor = widgets.Textarea(
    value=reviewed_text,
    placeholder="Edit the reviewed version here...",
    layout=widgets.Layout(width='100%', height='300px')
)
display(editor)

final_edited_text = editor.value
print(final_edited_text)

#Version Control with ChromaDB
import chromadb
from chromadb.config import Settings

client = chromadb.Client(Settings(anonymized_telemetry=False))
collection = client.get_or_create_collection(name="book_versions")

def save_version(book, chapter, version_id, content, role):
    doc_id = f"{book}_{chapter}_v{version_id}_{role}"
    metadata = {
        "book": book,
        "chapter": chapter,
        "version": version_id,
        "role": role
    }
    collection.add(documents=[content], metadatas=[metadata], ids=[doc_id])

save_version("The Gates of Morning", "Book1_Chapter1", "1", chapter_text, "original")
save_version("The Gates of Morning", "Book1_Chapter1", "2", spun_text, "writer")
save_version("The Gates of Morning", "Book1_Chapter1", "3", reviewed_text, "reviewer")
save_version("The Gates of Morning", "Book1_Chapter1", "4", final_edited_text, "editor")

#Semantic Search with ChromaDB
def semantic_search(query, top_k=5):
    results = collection.query(query_texts=[query], n_results=top_k)
    return results

results = semantic_search("Sea voyage and survival")

for doc, meta in zip(results["documents"][0], results["metadatas"][0]):
    print(f"Version {meta['version']} ({meta['role']}):\n{doc[:300]}")
    print("---")

# RL-Guided Retrieval with Feedback
import random

q_table = {}

def update_q_table(state, action, reward, alpha=0.1, gamma=0.9):
    old_value = q_table.get((state, action), 0.0)
    future_rewards = [q_table.get((state, a), 0.0) for a in ['original', 'writer', 'reviewer', 'editor']]
    new_value = old_value + alpha * (reward + gamma * max(future_rewards) - old_value)
    q_table[(state, action)] = new_value

#RL Search Function
def rl_guided_search(state, query, top_k=5):
    results = semantic_search(query, top_k=top_k)
    role_to_doc = {meta['role']: (doc, meta)
                   for doc, meta in zip(results["documents"][0], results["metadatas"][0])}
    available_roles = list(role_to_doc.keys())

    if not available_roles:
        return None

    if random.random() < 0.2:  # Exploration
        chosen_role = random.choice(available_roles)
    else:  # Exploitation
        chosen_role = max(available_roles, key=lambda r: q_table.get((state, r), 0.0))

    return role_to_doc[chosen_role], chosen_role

#User Feedback Loop:
def rl_episode(state, query):
    result, role = rl_guided_search(state, query)
    if not result:
        print("No versions found.")
        return

    content, meta = result
    print(f"\nðŸ“„ Preview ({role}):\n", content[:500])

    try:
        reward = int(input(f"\nRate the '{role}' version (0â€“10): "))
    except:
        reward = 5  # default

    update_q_table(state, role, reward)
    print(f"âœ… Updated Q-value for ({state}, {role}): {q_table[(state, role)]}")

